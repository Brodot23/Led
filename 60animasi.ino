/*
 * STOPLAMP BRODOT v2.0
 * Created by: Brodot23
 * Last Update: 2025-05-09 19:49:31 UTC
 * 
 * COMPLETE IMPLEMENTATION - PART 1/5
 * 
 * Complete Feature List:
 * 1. Display Modes:
 *    - Text Mode with customizable scrolling text
 *    - Animation Mode with 60 predefined patterns
 *    - Combined Mode (alternating between text and animation)
 * 
 * 2. Sein System:
 *    - Basic Arrow Mode
 *    - Edge Arrow Mode
 *    - Progressive Arrow Mode
 *    - Pulse Arrow Mode
 *    - Double Arrow Mode
 *    - Running Light Mode
 *    - Hazard Mode (both sides)
 *    - Adjustable speed & brightness
 * 
 * 3. Brake System:
 *    - Full Brake Mode (all LED segments)
 *    - Progressive Brake (filling animation)
 *    - Warning Brake (blinking pattern)
 *    - Emergency Brake (rapid flash)
 *    - Smooth Stop (fade effect)
 *    - "|| STOP!!! ||" Mode with dynamic bars
 *    - Adjustable intensity & timing
 * 
 * 4. Priority System:
 *    - SEIN (2) > BRAKE (1) > IDLE (0)
 *    - Automatic mode switching
 *    - State preservation
 * 
 * 5. Configuration:
 *    - Web Interface (192.168.4.1)
 *    - EEPROM Settings Storage
 *    - WiFi Configuration
 *    - Real-time updates
 * 
 * Hardware Requirements:
 * - ESP8266 (NodeMCU/Wemos D1 Mini)
 * - 8x MAX7219 LED Matrix
 * - Input switches (brake & sein)
 * - 5V Power Supply
 * 
 * Pin Configuration:
 * LED Matrix:
 * - DIN: GPIO 13 (D7)
 * - CLK: GPIO 14 (D5)
 * - CS:  GPIO 15 (D8)
 * 
 * Input:
 * - BRAKE: GPIO 4  (D2)
 * - SEIN_LEFT: GPIO 5  (D1)
 * - SEIN_RIGHT: GPIO 16 (D0)
 */

#include <ESP8266WiFi.h>
#include <ESP8266WebServer.h>
#include <EEPROM.h>
#include <ArduinoJson.h>
#include <LedControl.h>
#include <FS.h>
#include <SPI.h>
#include <MaxMatrix.h>
#include "settings.h"

// Deklarasi Fungsi
void leftSignal();
void rightSignal();
void brakeLight();
void hazardLight();
void parkingLight();
void customPattern(uint8_t patternIndex);
void setBrightness(uint8_t level);
void transitionEffect(uint8_t* oldPattern, uint8_t* newPattern);
void policeMode();
void runningLight();
void nightRiderEffect();
void strobeEffect();
void smoothAnimation(uint8_t* pattern1, uint8_t* pattern2, uint16_t duration);

Current Date: 2025-05-09 20:30:05 UTC
Current User: Brodot23
Version: STOPLAMP BRODOT v2.0

// Struct Definitions
struct Settings {
    uint8_t startupMode;    // 0: Text, 1: Animation, 2: Combined
    uint8_t brightness;     // 0-15
    uint16_t textSpeed;     // ms
    uint16_t animationSpeed;// ms
    char wifiSSID[32];
    char wifiPass[64];
    char customText[MAX_TEXT_LENGTH];
    bool wifiEnabled;
    uint8_t lastUsedBrakeMode;
    uint8_t lastUsedSeinMode;
};

struct AnimationSettings {
    uint8_t selectedPatterns[ANIMATION_COUNT];
    uint8_t patternCount;
    bool loopAnimation;
    uint8_t currentPattern;
    uint8_t currentStep;
    bool animationDirection;
};

struct SeinSettings {
    uint8_t mode;           // 0-5 modes
    uint16_t speed;         // Base speed in ms
    uint16_t edgeSpeed;     // Edge mode specific speed
    bool hazard;            // Hazard mode active
    char direction;         // 'L': Left, 'R': Right, 'H': Hazard, 'N': None
    uint8_t brightness;     // Sein-specific brightness
    uint8_t pattern[8];     // Current sein pattern
    struct {
        uint8_t steps;      // Steps for progressive mode
        uint16_t delay;     // Delay between steps
    } progressive;
};

struct BrakeSettings {
    uint8_t mode;           // 0-5 modes
    uint8_t level;          // 1-4 intensity levels
    uint8_t sensitivity;    // 1-5 sensitivity levels
    uint8_t intensity;      // 1-15 brightness levels
    struct {
        uint8_t steps;      // 3-5 steps
        uint16_t delay;     // ms between steps
    } progressive;
    bool preWarning;        // Pre-warning feature
    bool autoHazard;        // Auto hazard on hard brake
    uint8_t pattern[8];     // Current brake pattern
};

struct StateManager {
    uint8_t currentPriority;    // Current display priority
    bool isBraking;            // Brake state
    bool isSeining;            // Sein state
    uint8_t startupMode;       // Current startup mode
    unsigned long lastStateChange; // Timestamp of last state change
    bool isInitialized;        // System initialization flag
    struct {
        uint8_t step;          // Current animation step
        bool blinkState;       // Current blink state
        unsigned long lastUpdate; // Last update timestamp
    } animation;
};

// Define stop text pattern with line bars
const uint8_t STOP_TEXT[] = {
    0x66, 0x66, 0x66, 0x66,  // Left ||
    0x7E, 0x7E, 0x60, 0x7E,  // S
    0x7E, 0x18, 0x18, 0x7E,  // T
    0x7E, 0x66, 0x66, 0x66,  // O
    0x7E, 0x62, 0x62, 0x7E,  // P
    0x00, 0x00, 0x00, 0x00,  // Space
    0x21, 0x21, 0x21, 0x21,  // !!!
    0x66, 0x66, 0x66, 0x66   // Right ||
};

// Global Variables
LedControl lc = LedControl(DIN_PIN, CLK_PIN, CS_PIN, MATRIX_COUNT);
ESP8266WebServer server(80);

StateManager stateManager;
Settings settings;
AnimationSettings animSettings;
SeinSettings seinSettings;
BrakeSettings brakeSettings;

// Display buffers
uint8_t displayBuffer[MATRIX_COUNT][8];
uint8_t tempBuffer[MATRIX_COUNT][8];

// Timing variables
unsigned long lastUpdate = 0;
unsigned long lastBlinkUpdate = 0;
unsigned long lastScrollUpdate = 0;
unsigned long lastAnimationUpdate = 0;
unsigned long lastSeinUpdate = 0;
unsigned long lastBrakeUpdate = 0;

// State variables
uint8_t currentTextPosition = 0;
uint8_t currentAnimationFrame = 0;
uint8_t currentBrakeLevel = 0;
uint8_t currentSeinStep = 0;
bool blinkState = false;

// Function prototypes
void loadDefaultSettings();
void saveSettingsToEEPROM();
void loadSettingsFromEEPROM();
void initializeDisplay();
void initializeWiFi();
void initializeState();
void handlePriorityChange();
void clearAllDisplays();
void clearBuffer();
void copyBuffer();
void updateDisplay();
void handleWebServer();

#ifdef DEBUG
  #define DEBUG_PRINT(x) Serial.println(x)
#else
  #define DEBUG_PRINT(x)
#endif

void errorHandler(uint8_t errorCode) {
    switch(errorCode) {
        case 1:
            DEBUG_PRINT(F("Error: MAX7219 initialization failed"));
            break;
        case 2:
            DEBUG_PRINT(F("Error: Invalid pattern index"));
            break;
        case 3:
            DEBUG_PRINT(F("Error: Communication failure"));
            break;
        default:
            DEBUG_PRINT(F("Unknown error occurred"));
    }
    
    // Tampilkan kode error pada matrix
    uint8_t errorPattern[8] = {
        0x00, 0x00, 0x00, errorCode, errorCode, 0x00, 0x00, 0x00
    };
    displayPattern(errorPattern);
}

struct StoplampSettings {
    uint8_t brightness;
    uint8_t patternIndex;
    uint8_t mode;
};

StoplampSettings currentSettings;

// Fungsi EEPROM
void saveSettings() {
    // Fungsi untuk menyimpan settings ke EEPROM
void saveSettings() {
    // Simpan flag initialized untuk menandai EEPROM sudah terisi
    EEPROM.write(EEPROM_INITIALIZED_ADDR, EEPROM_INITIALIZED_KEY);
    
    // Simpan pengaturan ke EEPROM
    EEPROM.write(EEPROM_BRIGHTNESS_ADDR, currentSettings.brightness);
    EEPROM.write(EEPROM_PATTERN_ADDR, currentSettings.patternIndex);
    EEPROM.write(EEPROM_MODE_ADDR, currentSettings.mode);
    
    // Debug output jika DEBUG_MODE aktif
    #ifdef DEBUG_MODE
        Serial.println(F("Settings saved to EEPROM:"));
        Serial.print(F("Brightness: ")); 
        Serial.println(currentSettings.brightness);
        Serial.print(F("Pattern: ")); 
        Serial.println(currentSettings.patternIndex);
        Serial.print(F("Mode: ")); 
        Serial.println(currentSettings.mode);
    #endif
}
}

void loadSettings() {
    // Fungsi untuk memuat settings dari EEPROM
void loadSettings() {
    // Cek apakah EEPROM sudah diinisialisasi
    if (EEPROM.read(EEPROM_INITIALIZED_ADDR) != EEPROM_INITIALIZED_KEY) {
        // Jika belum, gunakan default settings
        currentSettings.brightness = 8;      // Default brightness (0-15)
        currentSettings.patternIndex = 0;    // Default pattern
        currentSettings.mode = 0;            // Default mode (normal)
        
        // Simpan default settings ke EEPROM
        saveSettings();
        
        #ifdef DEBUG_MODE
            Serial.println(F("First run - Default settings saved"));
        #endif
    } 
    else {
        // Baca settings yang tersimpan
        currentSettings.brightness = EEPROM.read(EEPROM_BRIGHTNESS_ADDR);
        currentSettings.patternIndex = EEPROM.read(EEPROM_PATTERN_ADDR);
        currentSettings.mode = EEPROM.read(EEPROM_MODE_ADDR);
        
        // Validasi nilai yang dibaca
        currentSettings.brightness = constrain(currentSettings.brightness, 0, 15);
        currentSettings.patternIndex = constrain(currentSettings.patternIndex, 0, NUM_PATTERNS - 1);
        currentSettings.mode = constrain(currentSettings.mode, 0, 5); // Sesuaikan dengan jumlah mode
        
        #ifdef DEBUG_MODE
            Serial.println(F("Settings loaded from EEPROM:"));
            Serial.print(F("Brightness: ")); 
            Serial.println(currentSettings.brightness);
            Serial.print(F("Pattern: ")); 
            Serial.println(currentSettings.patternIndex);
            Serial.print(F("Mode: ")); 
            Serial.println(currentSettings.mode);
        #endif
    }
    
    // Terapkan settings yang dimuat
    matrix.setIntensity(currentSettings.brightness);
    customPattern(currentSettings.patternIndex);
}
}

void updateSettings() {
    // Fungsi untuk mengupdate settings
void updateSettings(uint8_t brightness, uint8_t pattern, uint8_t mode) {
    bool changed = false;
    
    // Update brightness jika berbeda
    if (currentSettings.brightness != brightness) {
        currentSettings.brightness = brightness;
        matrix.setIntensity(brightness);  // Terapkan brightness baru
        changed = true;
    }
    
    // Update pattern jika berbeda
    if (currentSettings.patternIndex != pattern) {
        currentSettings.patternIndex = pattern;
        customPattern(pattern);  // Terapkan pattern baru
        changed = true;
    }
    
    // Update mode jika berbeda
    if (currentSettings.mode != mode) {
        currentSettings.mode = mode;
        changed = true;
    }
    
    // Jika ada perubahan, simpan ke EEPROM
    if (changed) {
        saveSettings();
        
        #ifdef DEBUG_MODE
            Serial.println(F("Settings updated:"));
            Serial.print(F("Brightness: ")); 
            Serial.println(currentSettings.brightness);
            Serial.print(F("Pattern: ")); 
            Serial.println(currentSettings.patternIndex);
            Serial.print(F("Mode: ")); 
            Serial.println(currentSettings.mode);
        #endif
    }
}
}

void setup() {
    Serial.begin(9600);
    void setup() {
    // Inisialisasi komunikasi serial untuk debugging
    Serial.begin(9600);
    
    // Inisialisasi MAX7219 LED Matrix
    matrix.init();  // Inisialisasi modul LED matrix
    matrix.setIntensity(8);  // Set brightness default (0-15)
    matrix.clear();  // Bersihkan display
    
    // Display startup animation/test
    uint8_t startupPattern[8] = {
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
    };
    displayPattern(startupPattern);
    delay(500);
    matrix.clear();
    
    // Load settings dari EEPROM
    loadSettings();
    
    #ifdef DEBUG_MODE
        displayVersionInfo();
        Serial.println(F("Setup completed"));
    #endif
}
    loadSettings();  // Tambahkan ini
}

void setup() {
    Serial.begin(115200);
    Serial.println("\nSTOPLAMP BRODOT v2.0");
    Serial.println("Starting system initialization...");
    
    // Initialize SPIFFS
    if (!SPIFFS.begin()) {
        Serial.println("ERROR: SPIFFS Mount Failed");
        while(1) { delay(100); } // Halt if SPIFFS fails
    }
    Serial.println("SPIFFS mounted successfully");


    // Initialize EEPROM
    EEPROM.begin(512);
    Serial.println("EEPROM initialized");
    
    // Configure input pins with internal pullup
    pinMode(BRAKE_PIN, INPUT_PULLUP);
    pinMode(SEIN_LEFT_PIN, INPUT_PULLUP);
    pinMode(SEIN_RIGHT_PIN, INPUT_PULLUP);
    Serial.println("Input pins configured");

    // Initialize LED Matrix controllers
    initializeDisplay();
    Serial.println("LED Matrix initialized");

    // Load settings or set defaults
    if (!loadSettingsFromEEPROM()) {
        Serial.println("No valid settings found, loading defaults");
        loadDefaultSettings();
        saveSettingsToEEPROM();
    } else {
        Serial.println("Settings loaded from EEPROM");
    }

    // Initialize WiFi
    initializeWiFi();
    Serial.println("WiFi initialized");

    // Initialize web server endpoints
    setupWebServer();
    Serial.println("Web server started");

    // Initialize system state
    initializeState();
    Serial.println("System state initialized");

    // Clear display buffers
    clearBuffer();
    clearAllDisplays();
    
    // Display startup animation
    displayStartupAnimation();
    
    Serial.println("Setup complete!");
    Serial.printf("Memory free: %d bytes\n", ESP.getFreeHeap());
}

void initializeDisplay() {
    for (int i = 0; i < MATRIX_COUNT; i++) {
        lc.shutdown(i, false);
        lc.setIntensity(i, settings.brightness);
        lc.clearDisplay(i);
    }
}

void loadDefaultSettings() {
    // Main settings
    settings.startupMode = MODE_TEXT;
    settings.brightness = 8;
    settings.textSpeed = DEFAULT_SCROLL_SPEED;
    settings.animationSpeed = DEFAULT_ANIMATION_SPEED;
    strcpy(settings.wifiSSID, "STOPLAMP_BRODOT");
    strcpy(settings.wifiPass, "12345678");
    strcpy(settings.customText, "STOPLAMP BRODOT v2.0");
    settings.wifiEnabled = true;
    settings.lastUsedBrakeMode = BRAKE_MODE_PROGRESSIVE;
    settings.lastUsedSeinMode = SEIN_MODE_EDGE;

    // Animation settings
    animSettings.patternCount = ANIMATION_COUNT;
    for (int i = 0; i < ANIMATION_COUNT; i++) {
        animSettings.selectedPatterns[i] = i;
    }
    animSettings.loopAnimation = true;
    animSettings.currentPattern = 0;
    animSettings.currentStep = 0;
    animSettings.animationDirection = true;

    // Sein settings
    seinSettings.mode = SEIN_MODE_EDGE;
    seinSettings.speed = DEFAULT_SEIN_SPEED;
    seinSettings.edgeSpeed = DEFAULT_SEIN_SPEED;
    seinSettings.hazard = false;
    seinSettings.direction = 'N';
    seinSettings.brightness = MAX_BRIGHTNESS;
    seinSettings.progressive.steps = 4;
    seinSettings.progressive.delay = 100;
    memset(seinSettings.pattern, 0, 8);

    // Brake settings
    brakeSettings.mode = BRAKE_MODE_PROGRESSIVE;
    brakeSettings.level = 2;
    brakeSettings.sensitivity = 3;
    brakeSettings.intensity = MAX_BRIGHTNESS;
    brakeSettings.progressive.steps = 4;
    brakeSettings.progressive.delay = DEFAULT_BRAKE_SPEED;
    brakeSettings.preWarning = true;
    brakeSettings.autoHazard = false;
    memset(brakeSettings.pattern, 0, 8);
}

bool loadSettingsFromEEPROM() {
    uint32_t signature;
    EEPROM.get(0, signature);
    
    if (signature != SETTINGS_SIGNATURE) {
        return false;
    }

    EEPROM.get(SETTINGS_BASE_ADDR, settings);
    EEPROM.get(ANIMATION_ADDR, animSettings);
    EEPROM.get(SEIN_SETTINGS_ADDR, seinSettings);
    EEPROM.get(BRAKE_SETTINGS_ADDR, brakeSettings);

    // Validate loaded settings
    if (settings.brightness > MAX_BRIGHTNESS ||
        settings.textSpeed < MIN_SPEED || settings.textSpeed > MAX_SPEED ||
        settings.animationSpeed < MIN_SPEED || settings.animationSpeed > MAX_SPEED) {
        return false;
    }

    return true;
}

void saveSettingsToEEPROM() {
    EEPROM.put(0, (uint32_t)SETTINGS_SIGNATURE);
    EEPROM.put(SETTINGS_BASE_ADDR, settings);
    EEPROM.put(ANIMATION_ADDR, animSettings);
    EEPROM.put(SEIN_SETTINGS_ADDR, seinSettings);
    EEPROM.put(BRAKE_SETTINGS_ADDR, brakeSettings);
    EEPROM.commit();
}

void initializeState() {
    stateManager.currentPriority = PRIORITY_IDLE;
    stateManager.isBraking = false;
    stateManager.isSeining = false;
    stateManager.startupMode = settings.startupMode;
    stateManager.lastStateChange = millis();
    stateManager.isInitialized = true;
    stateManager.animation.step = 0;
    stateManager.animation.blinkState = false;
    stateManager.animation.lastUpdate = millis();
}

void clearBuffer() {
    memset(displayBuffer, 0, sizeof(displayBuffer));
    memset(tempBuffer, 0, sizeof(tempBuffer));
}

void copyBuffer() {
    memcpy(displayBuffer, tempBuffer, sizeof(displayBuffer));
}

void clearAllDisplays() {
    for (int i = 0; i < MATRIX_COUNT; i++) {
        lc.clearDisplay(i);
    }
}

void displayStartupAnimation() {
    // Implementasi animasi startup
    // Efek fade in teks "STOPLAMP BRODOT v2.0"
    for (int brightness = 0; brightness <= settings.brightness; brightness++) {
        for (int i = 0; i < MATRIX_COUNT; i++) {
            lc.setIntensity(i, brightness);
        }
        displayScrollingText("STOPLAMP BRODOT v2.0", false);
        delay(50);
    }
    delay(1000);
    
    // Reset brightness
    for (int i = 0; i < MATRIX_COUNT; i++) {
        lc.setIntensity(i, settings.brightness);
    }
}

// Display Animation Functions
void displayAnimation() {
    if (millis() - lastAnimationUpdate >= settings.animationSpeed) {
        uint8_t* currentAnimationPattern = ANIMATION_PATTERNS[animSettings.selectedPatterns[animSettings.currentPattern]];
        
        // Update display with current frame
        for (int i = 0; i < MATRIX_COUNT; i++) {
            for (int row = 0; row < 8; row++) {
                displayBuffer[i][row] = currentAnimationPattern[i * 8 + row + animSettings.currentStep];
            }
            updateMatrixDisplay(i);
        }

        // Update animation state
        if (animSettings.animationDirection) {
            animSettings.currentStep++;
            if (animSettings.currentStep >= 16) {
                if (animSettings.loopAnimation) {
                    animSettings.currentStep = 0;
                    animSettings.currentPattern = (animSettings.currentPattern + 1) % animSettings.patternCount;
                } else {
                    animSettings.animationDirection = false;
                    animSettings.currentStep = 15;
                }
            }
        } else {
            animSettings.currentStep--;
            if (animSettings.currentStep == 0 || animSettings.currentStep > 16) {
                animSettings.animationDirection = true;
                animSettings.currentStep = 0;
                animSettings.currentPattern = (animSettings.currentPattern + 1) % animSettings.patternCount;
            }
        }
        
        lastAnimationUpdate = millis();
    }
}

// Sein Display Functions
void updateSeinDisplay() {
    switch (seinSettings.mode) {
        case SEIN_MODE_BASIC:
            displayBasicArrow();
            break;
        case SEIN_MODE_EDGE:
            displayEdgeArrow();
            break;
        case SEIN_MODE_PROGRESSIVE:
            displayProgressiveArrow();
            break;
        case SEIN_MODE_PULSE:
            displayPulseArrow();
            break;
        case SEIN_MODE_DOUBLE:
            displayDoubleArrow();
            break;
        case SEIN_MODE_RUNNING:
            displayRunningLight();
            break;
    }
}

void displayBasicArrow() {
    static const uint8_t arrowPattern[8] = {
        0b00011000,
        0b00111100,
        0b01111110,
        0b11111111,
        0b01111110,
        0b00111100,
        0b00011000,
        0b00000000
    };

    clearBuffer();
    
    if (millis() - lastSeinUpdate >= seinSettings.speed) {
        blinkState = !blinkState;
        lastSeinUpdate = millis();
    }

    if (blinkState) {
        if (seinSettings.direction == 'L' || seinSettings.direction == 'H') {
            for (int row = 0; row < 8; row++) {
                displayBuffer[0][row] = arrowPattern[row];
            }
        }
        if (seinSettings.direction == 'R' || seinSettings.direction == 'H') {
            for (int row = 0; row < 8; row++) {
                displayBuffer[7][row] = reverseByte(arrowPattern[row]);
            }
        }
    }

    updateAllDisplays();
}

void displayEdgeArrow() {
    static const uint8_t edgePattern[16] = {
        0b10000000, 0b11000000, 0b11100000, 0b11110000,
        0b11111000, 0b11111100, 0b11111110, 0b11111111,
        0b11111111, 0b11111110, 0b11111100, 0b11111000,
        0b11110000, 0b11100000, 0b11000000, 0b10000000
    };

    if (millis() - lastSeinUpdate >= seinSettings.edgeSpeed) {
        currentSeinStep = (currentSeinStep + 1) % 16;
        lastSeinUpdate = millis();
    }

    clearBuffer();

    if (seinSettings.direction == 'L' || seinSettings.direction == 'H') {
        for (int row = 0; row < 8; row++) {
            displayBuffer[0][row] = edgePattern[(currentSeinStep + row) % 16];
        }
    }
    if (seinSettings.direction == 'R' || seinSettings.direction == 'H') {
        for (int row = 0; row < 8; row++) {
            displayBuffer[7][row] = reverseByte(edgePattern[(currentSeinStep + row) % 16]);
        }
    }

    updateAllDisplays();
}

// Brake Display Functions
void updateBrakeDisplay() {
    switch (brakeSettings.mode) {
        case BRAKE_MODE_FULL:
            displayFullBrake();
            break;
        case BRAKE_MODE_PROGRESSIVE:
            displayProgressiveBrake();
            break;
        case BRAKE_MODE_WARNING:
            displayWarningBrake();
            break;
        case BRAKE_MODE_EMERGENCY:
            displayEmergencyBrake();
            break;
        case BRAKE_MODE_SMOOTH:
            displaySmoothBrake();
            break;
        case BRAKE_MODE_STOP_TEXT:
            displayStopMode();
            break;
    }
}

void displayFullBrake() {
    // Fill all matrices with maximum brightness
    for (int i = 0; i < MATRIX_COUNT; i++) {
        lc.setIntensity(i, brakeSettings.intensity);
        for (int row = 0; row < 8; row++) {
            displayBuffer[i][row] = 0xFF;
        }
    }
    updateAllDisplays();
}

void displayProgressiveBrake() {
    static uint8_t currentLevel = 0;
    static unsigned long lastProgressiveUpdate = 0;

    if (millis() - lastProgressiveUpdate >= brakeSettings.progressive.delay) {
        if (currentLevel < brakeSettings.progressive.steps) {
            currentLevel++;
        }
        lastProgressiveUpdate = millis();
    }

    clearBuffer();

    // Calculate fill level
    uint8_t fillPattern = 0;
    for (int i = 0; i < (8 * currentLevel / brakeSettings.progressive.steps); i++) {
        fillPattern |= (1 << i);
    }

    // Update all matrices
    for (int i = 0; i < MATRIX_COUNT; i++) {
        for (int row = 0; row < 8; row++) {
            displayBuffer[i][row] = fillPattern;
        }
    }

    updateAllDisplays();
}

void displayWarningBrake() {
    static bool warningState = false;
    static unsigned long lastWarningUpdate = 0;

    if (millis() - lastWarningUpdate >= 200) {
        warningState = !warningState;
        lastWarningUpdate = millis();
    }

    clearBuffer();

    if (warningState) {
        for (int i = 0; i < MATRIX_COUNT; i++) {
            for (int row = 0; row < 8; row++) {
                displayBuffer[i][row] = 0xFF;
            }
        }
    }

    updateAllDisplays();
}

// Utility Functions for Display
void updateMatrixDisplay(int matrix) {
    for (int row = 0; row < 8; row++) {
        lc.setRow(matrix, row, displayBuffer[matrix][row]);
    }
}

void updateAllDisplays() {
    for (int i = 0; i < MATRIX_COUNT; i++) {
        updateMatrixDisplay(i);
    }
}

uint8_t reverseByte(uint8_t b) {
    b = (b & 0xF0) >> 4 | (b & 0x0F) << 4;
    b = (b & 0xCC) >> 2 | (b & 0x33) << 2;
    b = (b & 0xAA) >> 1 | (b & 0x55) << 1;
    return b;
}

// Text Display Functions
void displayScrollingText(const char* text, bool scroll = true) {
    static int textPosition = 0;
    static unsigned long lastScrollUpdate = 0;
    
    if (scroll && millis() - lastScrollUpdate >= settings.textSpeed) {
        textPosition++;
        if (textPosition >= (strlen(text) * 8)) {
            textPosition = 0;
        }
        lastScrollUpdate = millis();
    }

    clearBuffer();
    
    int charIndex = textPosition / 8;
    int charOffset = textPosition % 8;
    
    for (int i = 0; i < MATRIX_COUNT + 1; i++) {
        if (charIndex + i < strlen(text)) {
            char currentChar = text[charIndex + i];
            const uint8_t* charPattern = getCharacterPattern(currentChar);
            
            for (int row = 0; row < 8; row++) {
                if (i == 0) {
                    if (i < MATRIX_COUNT) {
                        displayBuffer[i][row] = charPattern[row] << charOffset;
                    }
                } else {
                    if (i - 1 < MATRIX_COUNT) {
                        displayBuffer[i-1][row] |= charPattern[row] >> (8 - charOffset);
                    }
                }
            }
        }
    }
    
    updateAllDisplays();
}

// Main Loop
void loop() {
    // Handle web client requests
    server.handleClient();
    
    // Handle input and state updates
    handleInput();
    
    // Update display based on priority
    switch (stateManager.currentPriority) {
        case PRIORITY_SEIN:
            updateSeinDisplay();
            break;
            
        case PRIORITY_BRAKE:
            updateBrakeDisplay();
            break;
            
        case PRIORITY_IDLE:
            switch (settings.startupMode) {
                case MODE_TEXT:
                    displayScrollingText(settings.customText);
                    break;
                    
                case MODE_ANIMATION:
                    displayAnimation();
                    break;
                    
                case MODE_COMBINED:
                    if (millis() - stateManager.lastStateChange > 5000) {
                        settings.startupMode = (settings.startupMode == MODE_TEXT) ? 
                                              MODE_ANIMATION : MODE_TEXT;
                        stateManager.lastStateChange = millis();
                    }
                    if (settings.startupMode == MODE_TEXT) {
                        displayScrollingText(settings.customText);
                    } else {
                        displayAnimation();
                    }
                    break;
            }
            break;
    }
    
    // Allow WiFi stack processing
    yield();
}

// Input Handling
void handleInput() {
    // Read brake input (active low)
    bool brakeActive = !digitalRead(BRAKE_PIN);
    if (brakeActive != stateManager.isBraking) {
        stateManager.isBraking = brakeActive;
        if (brakeActive) {
            initializeBrakeMode();
        }
        handlePriorityChange();
    }
    
    // Read sein inputs (active low)
    bool leftActive = !digitalRead(SEIN_LEFT_PIN);
    bool rightActive = !digitalRead(SEIN_RIGHT_PIN);
    
    // Update sein state
    if (leftActive && rightActive && !seinSettings.hazard) {
        seinSettings.hazard = true;
        seinSettings.direction = 'H';
        stateManager.isSeining = true;
        initializeSeinMode();
    } else if (leftActive && !stateManager.isSeining) {
        seinSettings.hazard = false;
        seinSettings.direction = 'L';
        stateManager.isSeining = true;
        initializeSeinMode();
    } else if (rightActive && !stateManager.isSeining) {
        seinSettings.hazard = false;
        seinSettings.direction = 'R';
        stateManager.isSeining = true;
        initializeSeinMode();
    } else if (!leftActive && !rightActive && stateManager.isSeining) {
        seinSettings.hazard = false;
        seinSettings.direction = 'N';
        stateManager.isSeining = false;
        handlePriorityChange();
    }
}

// Web Server Implementation
void setupWebServer() {
    server.on("/", HTTP_GET, handleRoot);
    server.on("/settings", HTTP_GET, handleGetSettings);
    server.on("/settings", HTTP_POST, handlePostSettings);
    server.on("/animation", HTTP_GET, handleGetAnimation);
    server.on("/animation", HTTP_POST, handlePostAnimation);
    server.on("/brake", HTTP_GET, handleGetBrake);
    server.on("/brake", HTTP_POST, handlePostBrake);
    server.on("/sein", HTTP_GET, handleGetSein);
    server.on("/sein", HTTP_POST, handlePostSein);
    server.on("/reset", HTTP_POST, handleReset);
    
    server.onNotFound(handleNotFound);
    server.begin();
}

void handleRoot() {
    if (!SPIFFS.exists("/index.html")) {
        server.send(404, "text/plain", "File not found");
        return;
    }
    
    File file = SPIFFS.open("/index.html", "r");
    server.streamFile(file, "text/html");
    file.close();
}

void handleGetSettings() {
    StaticJsonDocument<512> doc;
    
    doc["startupMode"] = settings.startupMode;
    doc["brightness"] = settings.brightness;
    doc["textSpeed"] = settings.textSpeed;
    doc["animationSpeed"] = settings.animationSpeed;
    doc["customText"] = settings.customText;
    doc["wifiEnabled"] = settings.wifiEnabled;
    
    String response;
    serializeJson(doc, response);
    server.send(200, "application/json", response);
}

void handlePostSettings() {
    if (!server.hasArg("plain")) {
        server.send(400, "text/plain", "Missing body");
        return;
    }
    
    StaticJsonDocument<512> doc;
    DeserializationError error = deserializeJson(doc, server.arg("plain"));
    
    if (error) {
        server.send(400, "text/plain", "Invalid JSON");
        return;
    }
    
    // Update settings
    if (doc.containsKey("startupMode")) {
        settings.startupMode = doc["startupMode"];
    }
    if (doc.containsKey("brightness")) {
        settings.brightness = constrain(doc["brightness"], 0, MAX_BRIGHTNESS);
        for (int i = 0; i < MATRIX_COUNT; i++) {
            lc.setIntensity(i, settings.brightness);
        }
    }
    if (doc.containsKey("textSpeed")) {
        settings.textSpeed = constrain(doc["textSpeed"], MIN_SPEED, MAX_SPEED);
    }
    if (doc.containsKey("animationSpeed")) {
        settings.animationSpeed = constrain(doc["animationSpeed"], MIN_SPEED, MAX_SPEED);
    }
    if (doc.containsKey("customText")) {
        strlcpy(settings.customText, doc["customText"], MAX_TEXT_LENGTH);
    }
    if (doc.containsKey("wifiEnabled")) {
        settings.wifiEnabled = doc["wifiEnabled"];
    }
    
    saveSettingsToEEPROM();
    server.send(200, "text/plain", "Settings updated");
}

void handleReset() {
    server.send(200, "text/plain", "Resetting...");
    delay(100);
    loadDefaultSettings();
    saveSettingsToEEPROM();
    ESP.restart();
}

void handleNotFound() {
    String message = "File Not Found\n\n";
    message += "URI: ";
    message += server.uri();
    message += "\nMethod: ";
    message += (server.method() == HTTP_GET) ? "GET" : "POST";
    message += "\nArguments: ";
    message += server.args();
    message += "\n";
    
    for (uint8_t i = 0; i < server.args(); i++) {
        message += " " + server.argName(i) + ": " + server.arg(i) + "\n";
    }
    
    server.send(404, "text/plain", message);
}

// WiFi Setup
void initializeWiFi() {
    if (!settings.wifiEnabled) {
        return;
    }
    
    WiFi.mode(WIFI_AP);
    WiFi.softAP(settings.wifiSSID, settings.wifiPass);
    
    Serial.println("WiFi AP Started");
    Serial.print("SSID: ");
    Serial.println(settings.wifiSSID);
    Serial.print("IP Address: ");
    Serial.println(WiFi.softAPIP());
}

// Pattern Font Definitions
const uint8_t FONT_PATTERNS[128][8] = {
    // Spasi
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Space (32)
    
    // Tanda Baca
    {0x00, 0x00, 0x00, 0x4F, 0x4F, 0x00, 0x00, 0x00}, // ! (33)
    {0x00, 0x07, 0x07, 0x00, 0x07, 0x07, 0x00, 0x00}, // " (34)
    {0x14, 0x7F, 0x7F, 0x14, 0x7F, 0x7F, 0x14, 0x00}, // # (35)
    
    // Angka
    {0x24, 0x2E, 0x6B, 0x6B, 0x3A, 0x12, 0x00, 0x00}, // $ (36)
    {0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00, 0x00}, // % (37)
    {0x32, 0x7F, 0x4D, 0x4D, 0x77, 0x72, 0x50, 0x00}, // & (38)
    {0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00}, // ' (39)
    {0x00, 0x1C, 0x3E, 0x63, 0x41, 0x00, 0x00, 0x00}, // ( (40)
    {0x00, 0x41, 0x63, 0x3E, 0x1C, 0x00, 0x00, 0x00}, // ) (41)
    {0x08, 0x2A, 0x3E, 0x1C, 0x1C, 0x3E, 0x2A, 0x08}, // * (42)
    {0x08, 0x08, 0x3E, 0x3E, 0x08, 0x08, 0x00, 0x00}, // + (43)
    {0x00, 0x80, 0xE0, 0x60, 0x00, 0x00, 0x00, 0x00}, // , (44)
    {0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00}, // - (45)
    {0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00}, // . (46)
    {0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00}, // / (47)
    {0x3E, 0x7F, 0x71, 0x59, 0x4D, 0x7F, 0x3E, 0x00}, // 0 (48)
    {0x40, 0x42, 0x7F, 0x7F, 0x40, 0x40, 0x00, 0x00}, // 1 (49)
    {0x62, 0x73, 0x59, 0x49, 0x6F, 0x66, 0x00, 0x00}, // 2 (50)
    {0x22, 0x63, 0x49, 0x49, 0x7F, 0x36, 0x00, 0x00}, // 3 (51)
    {0x18, 0x1C, 0x16, 0x13, 0x7F, 0x7F, 0x10, 0x00}, // 4 (52)
    {0x27, 0x67, 0x45, 0x45, 0x7D, 0x39, 0x00, 0x00}, // 5 (53)
    {0x3C, 0x7E, 0x4B, 0x49, 0x79, 0x30, 0x00, 0x00}, // 6 (54)
    {0x03, 0x03, 0x71, 0x79, 0x0F, 0x07, 0x00, 0x00}, // 7 (55)
    {0x36, 0x7F, 0x49, 0x49, 0x7F, 0x36, 0x00, 0x00}, // 8 (56)
    {0x06, 0x4F, 0x49, 0x69, 0x3F, 0x1E, 0x00, 0x00}, // 9 (57)
    
    // Tanda Baca Lanjutan
    {0x00, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00}, // : (58)
    {0x00, 0x80, 0xE6, 0x66, 0x00, 0x00, 0x00, 0x00}, // ; (59)
    {0x08, 0x1C, 0x36, 0x63, 0x41, 0x00, 0x00, 0x00}, // < (60)
    {0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x00}, // = (61)
    {0x00, 0x41, 0x63, 0x36, 0x1C, 0x08, 0x00, 0x00}, // > (62)
    {0x02, 0x03, 0x51, 0x59, 0x0F, 0x06, 0x00, 0x00}, // ? (63)
    {0x3E, 0x7F, 0x41, 0x5D, 0x5D, 0x1F, 0x1E, 0x00}, // @ (64)
    
    // Huruf Besar
    {0x7E, 0x7F, 0x09, 0x09, 0x7F, 0x7E, 0x00, 0x00}, // A (65)
    {0x41, 0x7F, 0x7F, 0x49, 0x49, 0x7F, 0x36, 0x00}, // B (66)
    {0x1C, 0x3E, 0x63, 0x41, 0x41, 0x63, 0x22, 0x00}, // C (67)
    {0x41, 0x7F, 0x7F, 0x41, 0x63, 0x3E, 0x1C, 0x00}, // D (68)
    {0x41, 0x7F, 0x7F, 0x49, 0x5D, 0x41, 0x63, 0x00}, // E (69)
    {0x41, 0x7F, 0x7F, 0x49, 0x1D, 0x01, 0x03, 0x00}, // F (70)
    {0x1C, 0x3E, 0x63, 0x41, 0x51, 0x73, 0x72, 0x00}, // G (71)
    {0x7F, 0x7F, 0x08, 0x08, 0x7F, 0x7F, 0x00, 0x00}, // H (72)
    {0x00, 0x41, 0x7F, 0x7F, 0x41, 0x00, 0x00, 0x00}, // I (73)
    {0x30, 0x70, 0x40, 0x41, 0x7F, 0x3F, 0x01, 0x00}, // J (74)
    {0x41, 0x7F, 0x7F, 0x08, 0x1C, 0x77, 0x63, 0x00}, // K (75)
    {0x41, 0x7F, 0x7F, 0x41, 0x40, 0x60, 0x70, 0x00}, // L (76)
    {0x7F, 0x7F, 0x0E, 0x1C, 0x0E, 0x7F, 0x7F, 0x00}, // M (77)
    {0x7F, 0x7F, 0x06, 0x0C, 0x18, 0x7F, 0x7F, 0x00}, // N (78)
    {0x1C, 0x3E, 0x63, 0x41, 0x63, 0x3E, 0x1C, 0x00}, // O (79)
    {0x41, 0x7F, 0x7F, 0x49, 0x09, 0x0F, 0x06, 0x00}, // P (80)
    {0x1E, 0x3F, 0x21, 0x71, 0x7F, 0x5E, 0x00, 0x00}, // Q (81)
    {0x41, 0x7F, 0x7F, 0x09, 0x19, 0x7F, 0x66, 0x00}, // R (82)
    {0x26, 0x6F, 0x4D, 0x59, 0x73, 0x32, 0x00, 0x00}, // S (83)
    {0x03, 0x41, 0x7F, 0x7F, 0x41, 0x03, 0x00, 0x00}, // T (84)
    {0x7F, 0x7F, 0x40, 0x40, 0x7F, 0x7F, 0x00, 0x00}, // U (85)
    {0x1F, 0x3F, 0x60, 0x60, 0x3F, 0x1F, 0x00, 0x00}, // V (86)
    {0x7F, 0x7F, 0x30, 0x18, 0x30, 0x7F, 0x7F, 0x00}, // W (87)
    {0x43, 0x67, 0x3C, 0x18, 0x3C, 0x67, 0x43, 0x00}, // X (88)
    {0x07, 0x4F, 0x78, 0x78, 0x4F, 0x07, 0x00, 0x00}, // Y (89)
    {0x47, 0x63, 0x71, 0x59, 0x4D, 0x67, 0x73, 0x00}, // Z (90)
    
    // Simbol Tambahan
    {0x00, 0x7F, 0x7F, 0x41, 0x41, 0x00, 0x00, 0x00}, // [ (91)
    {0x01, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00}, // \ (92)
    {0x00, 0x41, 0x41, 0x7F, 0x7F, 0x00, 0x00, 0x00}, // ] (93)
    {0x08, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x08, 0x00}, // ^ (94)
    {0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80}  // _ (95)
};

// 60 Pola Animasi
const uint8_t ANIMATION_PATTERNS[60][64] = {
    // 1. Wave Pattern
    {
        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
        0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01,
        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
        0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01,
        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
        0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01,
        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
        0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01
    },
    
    // 2. Heartbeat Pattern
    {
        0x00, 0x00, 0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF,
        0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00, 0x00,
        0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00,
        0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7E, 0x3C, 0x18
    },
    
    // 3. Rain Pattern
    {
        0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01,
        0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01,
        0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01,
        0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01,
        0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01,
        0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01,
        0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01,
        0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01
    },
    
        // 4. Spiral Pattern
    {
        0xFF, 0x80, 0xBF, 0xA0, 0xAF, 0xA8, 0xAB, 0xAA,
        0xAA, 0xAB, 0xA8, 0xAF, 0xA0, 0xBF, 0x80, 0xFF,
        0xFF, 0x01, 0xFD, 0x05, 0xF5, 0x15, 0xD5, 0x55,
        0x55, 0xD5, 0x15, 0xF5, 0x05, 0xFD, 0x01, 0xFF,
        0xFF, 0x80, 0xBF, 0xA0, 0xAF, 0xA8, 0xAB, 0xAA,
        0xAA, 0xAB, 0xA8, 0xAF, 0xA0, 0xBF, 0x80, 0xFF,
        0xFF, 0x01, 0xFD, 0x05, 0xF5, 0x15, 0xD5, 0x55,
        0x55, 0xD5, 0x15, 0xF5, 0x05, 0xFD, 0x01, 0xFF
    },

    // 5. Pulse Pattern
    {
        0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x7E, 0x3C, 0x18,
        0x3C, 0x7E, 0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00,
        0x7E, 0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00, 0x00,
        0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00,
        0xFF, 0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,
        0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },

    // 6. Diamond Pattern
    {
        0x00, 0x18, 0x3C, 0x7E, 0x7E, 0x3C, 0x18, 0x00,
        0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x7E, 0x3C, 0x18,
        0x3C, 0x7E, 0xFF, 0xFF, 0xFF, 0xFF, 0x7E, 0x3C,
        0x7E, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7E,
        0x7E, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7E,
        0x3C, 0x7E, 0xFF, 0xFF, 0xFF, 0xFF, 0x7E, 0x3C,
        0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x7E, 0x3C, 0x18,
        0x00, 0x18, 0x3C, 0x7E, 0x7E, 0x3C, 0x18, 0x00
    },

    // 7. Double Wave Pattern
    {
        0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
        0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x81,
        0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x81, 0x42,
        0x18, 0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24,
        0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18,
        0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18, 0x18,
        0x42, 0x81, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24,
        0x81, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42
    },

    // 8. Circular Pattern
    {
        0x3C, 0x42, 0x81, 0x81, 0x81, 0x81, 0x42, 0x3C,
        0x42, 0x81, 0x81, 0x81, 0x81, 0x42, 0x3C, 0x00,
        0x81, 0x81, 0x81, 0x81, 0x42, 0x3C, 0x00, 0x00,
        0x81, 0x81, 0x81, 0x42, 0x3C, 0x00, 0x00, 0x00,
        0x81, 0x81, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00,
        0x81, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },

    // 9. X Pattern
    {
        0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
        0x42, 0x81, 0x42, 0x24, 0x24, 0x42, 0x81, 0x42,
        0x24, 0x42, 0x81, 0x42, 0x42, 0x81, 0x42, 0x24,
        0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18,
        0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18,
        0x24, 0x42, 0x81, 0x42, 0x42, 0x81, 0x42, 0x24,
        0x42, 0x81, 0x42, 0x24, 0x24, 0x42, 0x81, 0x42,
        0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81
    },

    // 10. Expanding Box Pattern
    {
        0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x3C, 0x24, 0x24, 0x3C, 0x00, 0x00,
        0x00, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x7E, 0x00,
        0xFF, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFF,
        0xFF, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFF,
        0x00, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x7E, 0x00,
        0x00, 0x00, 0x3C, 0x24, 0x24, 0x3C, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00
    },

        // 11. Zigzag Pattern
    {
        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
        0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x02,
        0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x40, 0x20,
        0x10, 0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08,
        0x10, 0x20, 0x40, 0x80, 0x40, 0x20, 0x10, 0x08,
        0x04, 0x02, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
        0x40, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02,
        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80
    },

    // 12. Snake Pattern
    {
        0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0xFF,
        0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01, 0x00,
        0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F,
        0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80,
        0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0xFF,
        0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01, 0x00,
        0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F,
        0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80
    },

    // 13. Star Pattern
    {
        0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x24, 0x18, 0x18, 0x24, 0x00, 0x00,
        0x00, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x00,
        0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
        0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
        0x00, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x00,
        0x00, 0x00, 0x24, 0x18, 0x18, 0x24, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00
    },

    // 14. Double Helix Pattern
    {
        0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
        0x42, 0x81, 0x42, 0x24, 0x24, 0x42, 0x81, 0x42,
        0x24, 0x42, 0x81, 0x42, 0x42, 0x81, 0x42, 0x24,
        0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18,
        0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18,
        0x24, 0x42, 0x81, 0x42, 0x42, 0x81, 0x42, 0x24,
        0x42, 0x81, 0x42, 0x24, 0x24, 0x42, 0x81, 0x42,
        0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81
    },

    // 15. Rain Drop Pattern
    {
        0x80, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x01,
        0x40, 0x80, 0x00, 0x00, 0x04, 0x08, 0x00, 0x00,
        0x20, 0x40, 0x80, 0x00, 0x02, 0x04, 0x08, 0x00,
        0x10, 0x20, 0x40, 0x80, 0x01, 0x02, 0x04, 0x08,
        0x08, 0x10, 0x20, 0x40, 0x80, 0x01, 0x02, 0x04,
        0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x01, 0x02,
        0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x01,
        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80
    },

        // 16. Firework Pattern
    {
        0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00,
        0x00, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E,
        0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C,
        0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },

    // 17. Matrix Pattern
    {
        0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF,
        0x02, 0x06, 0x0E, 0x1E, 0x3E, 0x7E, 0xFE, 0xFF,
        0x04, 0x0C, 0x1C, 0x3C, 0x7C, 0xFC, 0xFF, 0xFF,
        0x08, 0x18, 0x38, 0x78, 0xF8, 0xFF, 0xFF, 0xFF,
        0x10, 0x30, 0x70, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF,
        0x20, 0x60, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0x40, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
    },

    // 18. Checker Pattern
    {
        0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,
        0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA,
        0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,
        0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA,
        0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,
        0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA,
        0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,
        0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA
    },

    // 19. DNA Pattern
    {
        0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
        0x42, 0x81, 0x42, 0x24, 0x24, 0x42, 0x81, 0x42,
        0x24, 0x42, 0x81, 0x42, 0x42, 0x81, 0x42, 0x24,
        0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18,
        0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18,
        0x24, 0x42, 0x81, 0x42, 0x42, 0x81, 0x42, 0x24,
        0x42, 0x81, 0x42, 0x24, 0x24, 0x42, 0x81, 0x42,
        0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81
    },

    // 20. Binary Counter Pattern
    {
        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
        0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x81,
        0x07, 0x0E, 0x1C, 0x38, 0x70, 0xE0, 0xC1, 0x83,
        0x0F, 0x1E, 0x3C, 0x78, 0xF0, 0xE1, 0xC3, 0x87,
        0x1F, 0x3E, 0x7C, 0xF8, 0xF1, 0xE3, 0xC7, 0x8F,
        0x3F, 0x7E, 0xFC, 0xF9, 0xF3, 0xE7, 0xCF, 0x9F,
        0x7F, 0xFE, 0xFD, 0xFB, 0xF7, 0xEF, 0xDF, 0xBF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
    },

        // 21. Expanding Circle Pattern
    {
        0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x3C, 0x24, 0x24, 0x3C, 0x00, 0x00,
        0x00, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x7E, 0x00,
        0xFF, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFF,
        0xFF, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFF,
        0x00, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x7E, 0x00,
        0x00, 0x00, 0x3C, 0x24, 0x24, 0x3C, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00
    },

    // 22. Pinwheel Pattern
    {
        0x81, 0xC3, 0xE7, 0xFF, 0xFF, 0xE7, 0xC3, 0x81,
        0xC3, 0xE7, 0xFF, 0xFF, 0xE7, 0xC3, 0x81, 0x00,
        0xE7, 0xFF, 0xFF, 0xE7, 0xC3, 0x81, 0x00, 0x00,
        0xFF, 0xFF, 0xE7, 0xC3, 0x81, 0x00, 0x00, 0x00,
        0xFF, 0xE7, 0xC3, 0x81, 0x00, 0x00, 0x00, 0x00,
        0xE7, 0xC3, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xC3, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },

    // 23. Random Dots Pattern
    {
        0x84, 0x12, 0x48, 0x21, 0x84, 0x12, 0x48, 0x21,
        0x21, 0x84, 0x12, 0x48, 0x21, 0x84, 0x12, 0x48,
        0x48, 0x21, 0x84, 0x12, 0x48, 0x21, 0x84, 0x12,
        0x12, 0x48, 0x21, 0x84, 0x12, 0x48, 0x21, 0x84,
        0x84, 0x12, 0x48, 0x21, 0x84, 0x12, 0x48, 0x21,
        0x21, 0x84, 0x12, 0x48, 0x21, 0x84, 0x12, 0x48,
        0x48, 0x21, 0x84, 0x12, 0x48, 0x21, 0x84, 0x12,
        0x12, 0x48, 0x21, 0x84, 0x12, 0x48, 0x21, 0x84
    },

    // 24. Spinning Square Pattern
    {
        0xFF, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFF,
        0x7E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7E,
        0x3C, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x3C,
        0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
        0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
        0x3C, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x3C,
        0x7E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7E,
        0xFF, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFF
    },

    // 25. Cross Pattern
    {
        0x18, 0x18, 0x18, 0xFF, 0xFF, 0x18, 0x18, 0x18,
        0x18, 0x18, 0x18, 0xFF, 0xFF, 0x18, 0x18, 0x18,
        0x18, 0x18, 0x18, 0xFF, 0xFF, 0x18, 0x18, 0x18,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0x18, 0x18, 0x18, 0xFF, 0xFF, 0x18, 0x18, 0x18,
        0x18, 0x18, 0x18, 0xFF, 0xFF, 0x18, 0x18, 0x18,
        0x18, 0x18, 0x18, 0xFF, 0xFF, 0x18, 0x18, 0x18
    },

        // 26. Arrow Pattern
    {
        0x10, 0x18, 0x1C, 0xFE, 0xFE, 0x1C, 0x18, 0x10,
        0x20, 0x30, 0x38, 0xFC, 0xFC, 0x38, 0x30, 0x20,
        0x40, 0x60, 0x70, 0xF8, 0xF8, 0x70, 0x60, 0x40,
        0x80, 0xC0, 0xE0, 0xF0, 0xF0, 0xE0, 0xC0, 0x80,
        0x80, 0xC0, 0xE0, 0xF0, 0xF0, 0xE0, 0xC0, 0x80,
        0x40, 0x60, 0x70, 0xF8, 0xF8, 0x70, 0x60, 0x40,
        0x20, 0x30, 0x38, 0xFC, 0xFC, 0x38, 0x30, 0x20,
        0x10, 0x18, 0x1C, 0xFE, 0xFE, 0x1C, 0x18, 0x10
    },

    // 27. Double Ring Pattern
    {
        0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00,
        0x3C, 0x42, 0x81, 0x81, 0x81, 0x81, 0x42, 0x3C,
        0x42, 0x81, 0xFF, 0xFF, 0xFF, 0xFF, 0x81, 0x42,
        0x42, 0x81, 0xFF, 0xFF, 0xFF, 0xFF, 0x81, 0x42,
        0x42, 0x81, 0xFF, 0xFF, 0xFF, 0xFF, 0x81, 0x42,
        0x42, 0x81, 0xFF, 0xFF, 0xFF, 0xFF, 0x81, 0x42,
        0x3C, 0x42, 0x81, 0x81, 0x81, 0x81, 0x42, 0x3C,
        0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00
    },

    // 28. Infinity Pattern
    {
        0x00, 0x00, 0x3C, 0x42, 0x42, 0x3C, 0x00, 0x00,
        0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00,
        0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C,
        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
        0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C,
        0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00,
        0x00, 0x00, 0x3C, 0x42, 0x42, 0x3C, 0x00, 0x00
    },

    // 29. Interleaved Pattern
    {
        0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,
        0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA,
        0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,
        0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA,
        0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,
        0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA,
        0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,
        0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA
    },

    // 30. Windmill Pattern
    {
        0xFF, 0x83, 0x85, 0x89, 0x91, 0xA1, 0xC1, 0xFF,
        0xFF, 0xC1, 0xA1, 0x91, 0x89, 0x85, 0x83, 0xFF,
        0xFF, 0x83, 0x85, 0x89, 0x91, 0xA1, 0xC1, 0xFF,
        0xFF, 0xC1, 0xA1, 0x91, 0x89, 0x85, 0x83, 0xFF,
        0xFF, 0x83, 0x85, 0x89, 0x91, 0xA1, 0xC1, 0xFF,
        0xFF, 0xC1, 0xA1, 0x91, 0x89, 0x85, 0x83, 0xFF,
        0xFF, 0x83, 0x85, 0x89, 0x91, 0xA1, 0xC1, 0xFF,
        0xFF, 0xC1, 0xA1, 0x91, 0x89, 0x85, 0x83, 0xFF
    },

        // 31. Rotating Lines Pattern
    {
        0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
        0x03, 0x84, 0x48, 0x30, 0x30, 0x48, 0x84, 0x03,
        0x06, 0x09, 0x90, 0x60, 0x60, 0x90, 0x09, 0x06,
        0x0C, 0x12, 0x21, 0xC0, 0xC0, 0x21, 0x12, 0x0C,
        0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18,
        0x30, 0x48, 0x84, 0x03, 0x03, 0x84, 0x48, 0x30,
        0x60, 0x90, 0x09, 0x06, 0x06, 0x09, 0x90, 0x60,
        0xC0, 0x21, 0x12, 0x0C, 0x0C, 0x12, 0x21, 0xC0
    },

    // 32. Starburst Pattern
    {
        0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x7E, 0x3C, 0x18,
        0x24, 0x66, 0xE7, 0xFF, 0xFF, 0xE7, 0x66, 0x24,
        0x42, 0xC3, 0xC3, 0xFF, 0xFF, 0xC3, 0xC3, 0x42,
        0x81, 0x81, 0x81, 0xFF, 0xFF, 0x81, 0x81, 0x81,
        0x81, 0x81, 0x81, 0xFF, 0xFF, 0x81, 0x81, 0x81,
        0x42, 0xC3, 0xC3, 0xFF, 0xFF, 0xC3, 0xC3, 0x42,
        0x24, 0x66, 0xE7, 0xFF, 0xFF, 0xE7, 0x66, 0x24,
        0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x7E, 0x3C, 0x18
    },

    // 33. Wave Motion Pattern
    {
        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
        0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x01,
        0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x01, 0x02,
        0x08, 0x10, 0x20, 0x40, 0x80, 0x01, 0x02, 0x04,
        0x10, 0x20, 0x40, 0x80, 0x01, 0x02, 0x04, 0x08,
        0x20, 0x40, 0x80, 0x01, 0x02, 0x04, 0x08, 0x10,
        0x40, 0x80, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
        0x80, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40
    },

    // 34. DNA Double Helix Pattern
    {
        0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x81,
        0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x81, 0x42,
        0x18, 0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24,
        0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18,
        0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18, 0x18,
        0x42, 0x81, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24,
        0x81, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42,
        0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81
    },

    // 35. Pulse Wave Pattern
    {
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
    },

        // 36. Radar Sweep Pattern
    {
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x0F, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x1F, 0x0F, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00,
        0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01, 0x00, 0x00,
        0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01, 0x00,
        0xFF, 0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01
    },

    // 37. Kaleidoscope Pattern
    {
        0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
        0x42, 0x81, 0x42, 0x24, 0x24, 0x42, 0x81, 0x42,
        0x24, 0x42, 0x81, 0x42, 0x42, 0x81, 0x42, 0x24,
        0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18,
        0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18,
        0x24, 0x42, 0x81, 0x42, 0x42, 0x81, 0x42, 0x24,
        0x42, 0x81, 0x42, 0x24, 0x24, 0x42, 0x81, 0x42,
        0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81
    },

    // 38. Digital Rain Pattern
    {
        0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01,
        0x01, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02,
        0x02, 0x01, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04,
        0x04, 0x02, 0x01, 0x80, 0x40, 0x20, 0x10, 0x08,
        0x08, 0x04, 0x02, 0x01, 0x80, 0x40, 0x20, 0x10,
        0x10, 0x08, 0x04, 0x02, 0x01, 0x80, 0x40, 0x20,
        0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x80, 0x40,
        0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x80
    },

    // 39. Rotating Cross Pattern
    {
        0x18, 0x18, 0x18, 0xFF, 0xFF, 0x18, 0x18, 0x18,
        0x00, 0x24, 0x24, 0xFF, 0xFF, 0x24, 0x24, 0x00,
        0x00, 0x00, 0x42, 0xFF, 0xFF, 0x42, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x42, 0xFF, 0xFF, 0x42, 0x00, 0x00,
        0x00, 0x24, 0x24, 0xFF, 0xFF, 0x24, 0x24, 0x00,
        0x18, 0x18, 0x18, 0xFF, 0xFF, 0x18, 0x18, 0x18,
        0x3C, 0x3C, 0x3C, 0xFF, 0xFF, 0x3C, 0x3C, 0x3C
    },

    // 40. Sierpinski Triangle Pattern
    {
        0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF,
        0x02, 0x06, 0x0E, 0x1E, 0x3E, 0x7E, 0xFE, 0x00,
        0x04, 0x0C, 0x1C, 0x3C, 0x7C, 0xFC, 0x00, 0x00,
        0x08, 0x18, 0x38, 0x78, 0xF8, 0x00, 0x00, 0x00,
        0x10, 0x30, 0x70, 0xF0, 0x00, 0x00, 0x00, 0x00,
        0x20, 0x60, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x40, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },

       // 41. Sine Wave Pattern
    {
        0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01,
        0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x02,
        0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x02, 0x04,
        0x10, 0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08,
        0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08, 0x10,
        0x04, 0x02, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
        0x02, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,
        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80
    },

    // 42. Fibonacci Spiral Pattern
    {
        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
        0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x81,
        0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x81, 0x83,
        0x08, 0x10, 0x20, 0x40, 0x80, 0x81, 0x83, 0x87,
        0x10, 0x20, 0x40, 0x80, 0x81, 0x83, 0x87, 0x8F,
        0x20, 0x40, 0x80, 0x81, 0x83, 0x87, 0x8F, 0x9F,
        0x40, 0x80, 0x81, 0x83, 0x87, 0x8F, 0x9F, 0xBF,
        0x80, 0x81, 0x83, 0x87, 0x8F, 0x9F, 0xBF, 0xFF
    },

    // 43. Binary Clock Pattern
    {
        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
        0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x81,
        0x07, 0x0E, 0x1C, 0x38, 0x70, 0xE0, 0xC1, 0x83,
        0x0F, 0x1E, 0x3C, 0x78, 0xF0, 0xE1, 0xC3, 0x87,
        0x1F, 0x3E, 0x7C, 0xF8, 0xF1, 0xE3, 0xC7, 0x8F,
        0x3F, 0x7E, 0xFC, 0xF9, 0xF3, 0xE7, 0xCF, 0x9F,
        0x7F, 0xFE, 0xFD, 0xFB, 0xF7, 0xEF, 0xDF, 0xBF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
    },

    // 44. Moving Dots Pattern
    {
        0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
        0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x42,
        0x24, 0x18, 0x18, 0x24, 0x42, 0x81, 0x42, 0x24,
        0x18, 0x18, 0x24, 0x42, 0x81, 0x42, 0x24, 0x18,
        0x18, 0x24, 0x42, 0x81, 0x42, 0x24, 0x18, 0x18,
        0x24, 0x42, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24,
        0x42, 0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42,
        0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81
    },

    // 45. Expanding Ring Pattern
    {
        0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18,
        0x3C, 0x42, 0x81, 0x81, 0x81, 0x81, 0x42, 0x3C,
        0x7E, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x7E,
        0xFF, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFF,
        0xFF, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xFF,
        0xFF, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
    },

        // 46. Circuit Board Pattern
    {
        0xFF, 0x81, 0xBD, 0xBD, 0xBD, 0xBD, 0x81, 0xFF,
        0xFF, 0x81, 0xA5, 0xA5, 0xA5, 0xA5, 0x81, 0xFF,
        0xFF, 0x81, 0x99, 0x99, 0x99, 0x99, 0x81, 0xFF,
        0xFF, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFF,
        0xFF, 0x81, 0xBD, 0xBD, 0xBD, 0xBD, 0x81, 0xFF,
        0xFF, 0x81, 0xA5, 0xA5, 0xA5, 0xA5, 0x81, 0xFF,
        0xFF, 0x81, 0x99, 0x99, 0x99, 0x99, 0x81, 0xFF,
        0xFF, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFF
    },

    // 47. Pixel Rain Pattern
    {
        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
        0x80, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,
        0x40, 0x80, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
        0x20, 0x40, 0x80, 0x01, 0x02, 0x04, 0x08, 0x10,
        0x10, 0x20, 0x40, 0x80, 0x01, 0x02, 0x04, 0x08,
        0x08, 0x10, 0x20, 0x40, 0x80, 0x01, 0x02, 0x04,
        0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x01, 0x02,
        0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x01
    },

    // 48. Hypnotic Pattern
    {
        0xFF, 0x81, 0xBD, 0xA5, 0xA5, 0xBD, 0x81, 0xFF,
        0x7E, 0x42, 0x5A, 0x5A, 0x5A, 0x5A, 0x42, 0x7E,
        0x3C, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x3C,
        0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
        0x3C, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x3C,
        0x7E, 0x42, 0x5A, 0x5A, 0x5A, 0x5A, 0x42, 0x7E,
        0xFF, 0x81, 0xBD, 0xA5, 0xA5, 0xBD, 0x81, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
    },

    // 49. Binary Tree Pattern
    {
        0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01,
        0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x00,
        0xE0, 0x70, 0x38, 0x1C, 0x0E, 0x07, 0x00, 0x00,
        0xF0, 0x78, 0x3C, 0x1E, 0x0F, 0x00, 0x00, 0x00,
        0xF8, 0x7C, 0x3E, 0x1F, 0x00, 0x00, 0x00, 0x00,
        0xFC, 0x7E, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFE, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },

    // 50. Morse Code Pattern
    {
        0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
        0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
        0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0x00,
        0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF,
        0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00,
        0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
        0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0x00,
        0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF
    },

        // 51. Digital Clock Pattern
    {
        0xFF, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFF,
        0x00, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x00,
        0xFF, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFF,
        0x00, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x00,
        0xFF, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFF,
        0x00, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x00,
        0xFF, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFF,
        0x00, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x00
    },

    // 52. Quantum Pattern
    {
        0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18,
        0x24, 0x42, 0x81, 0x00, 0x00, 0x81, 0x42, 0x24,
        0x42, 0x81, 0x00, 0x00, 0x00, 0x00, 0x81, 0x42,
        0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81,
        0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81,
        0x42, 0x81, 0x00, 0x00, 0x00, 0x00, 0x81, 0x42,
        0x24, 0x42, 0x81, 0x00, 0x00, 0x81, 0x42, 0x24,
        0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18
    },

    // 53. Diagonal Wave Pattern
    {
        0x80, 0x41, 0x22, 0x14, 0x08, 0x14, 0x22, 0x41,
        0x41, 0x22, 0x14, 0x08, 0x14, 0x22, 0x41, 0x80,
        0x22, 0x14, 0x08, 0x14, 0x22, 0x41, 0x80, 0x41,
        0x14, 0x08, 0x14, 0x22, 0x41, 0x80, 0x41, 0x22,
        0x08, 0x14, 0x22, 0x41, 0x80, 0x41, 0x22, 0x14,
        0x14, 0x22, 0x41, 0x80, 0x41, 0x22, 0x14, 0x08,
        0x22, 0x41, 0x80, 0x41, 0x22, 0x14, 0x08, 0x14,
        0x41, 0x80, 0x41, 0x22, 0x14, 0x08, 0x14, 0x22
    },

    // 54. Binary Counter Pattern
    {
        0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F,
        0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF,
        0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF, 0xFE,
        0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF, 0xFE, 0xFC,
        0x0F, 0x1F, 0x3F, 0x7F, 0xFF, 0xFE, 0xFC, 0xF8,
        0x1F, 0x3F, 0x7F, 0xFF, 0xFE, 0xFC, 0xF8, 0xF0,
        0x3F, 0x7F, 0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0,
        0x7F, 0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0
    },

    // 55. Fractal Pattern
    {
        0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81,
        0x42, 0x81, 0x42, 0x24, 0x24, 0x42, 0x81, 0x42,
        0x24, 0x42, 0x81, 0x42, 0x42, 0x81, 0x42, 0x24,
        0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18,
        0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18,
        0x24, 0x42, 0x81, 0x42, 0x42, 0x81, 0x42, 0x24,
        0x42, 0x81, 0x42, 0x24, 0x24, 0x42, 0x81, 0x42,
        0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81
    },

        // 56. Vortex Pattern
    {
        0xFF, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFF,
        0x81, 0xFF, 0x81, 0x81, 0x81, 0x81, 0xFF, 0x81,
        0x81, 0x81, 0xFF, 0x81, 0x81, 0xFF, 0x81, 0x81,
        0x81, 0x81, 0x81, 0xFF, 0xFF, 0x81, 0x81, 0x81,
        0x81, 0x81, 0x81, 0xFF, 0xFF, 0x81, 0x81, 0x81,
        0x81, 0x81, 0xFF, 0x81, 0x81, 0xFF, 0x81, 0x81,
        0x81, 0xFF, 0x81, 0x81, 0x81, 0x81, 0xFF, 0x81,
        0xFF, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFF
    },

    // 57. Double Spiral Pattern
    {
        0x01, 0x03, 0x07, 0x0F, 0xF0, 0xE0, 0xC0, 0x80,
        0x03, 0x07, 0x0F, 0x1F, 0xF8, 0xF0, 0xE0, 0xC0,
        0x07, 0x0F, 0x1F, 0x3F, 0xFC, 0xF8, 0xF0, 0xE0,
        0x0F, 0x1F, 0x3F, 0x7F, 0xFE, 0xFC, 0xF8, 0xF0,
        0xF0, 0xF8, 0xFC, 0xFE, 0x7F, 0x3F, 0x1F, 0x0F,
        0xE0, 0xF0, 0xF8, 0xFC, 0x3F, 0x1F, 0x0F, 0x07,
        0xC0, 0xE0, 0xF0, 0xF8, 0x1F, 0x0F, 0x07, 0x03,
        0x80, 0xC0, 0xE0, 0xF0, 0x0F, 0x07, 0x03, 0x01
    },

    // 58. Maze Pattern
    {
        0xFF, 0x81, 0xBD, 0xBD, 0xBD, 0xBD, 0x81, 0xFF,
        0xFF, 0xBD, 0x81, 0xBD, 0xBD, 0x81, 0xBD, 0xFF,
        0xFF, 0xBD, 0xBD, 0x81, 0x81, 0xBD, 0xBD, 0xFF,
        0xFF, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xFF,
        0xFF, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xFF,
        0xFF, 0xBD, 0xBD, 0x81, 0x81, 0xBD, 0xBD, 0xFF,
        0xFF, 0xBD, 0x81, 0xBD, 0xBD, 0x81, 0xBD, 0xFF,
        0xFF, 0x81, 0xBD, 0xBD, 0xBD, 0xBD, 0x81, 0xFF
    },

    // 59. Pulse Ring Pattern
    {
        0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18,
        0x24, 0x42, 0x81, 0x81, 0x81, 0x81, 0x42, 0x24,
        0x42, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x42,
        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
        0x42, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x42,
        0x24, 0x42, 0x81, 0x81, 0x81, 0x81, 0x42, 0x24,
        0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18
    },

    // 60. Binary Explosion Pattern
    {
        0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x7E, 0x3C, 0x18,
        0x3C, 0x7E, 0xFF, 0xFF, 0xFF, 0xFF, 0x7E, 0x3C,
        0x7E, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7E,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0x7E, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7E,
        0x3C, 0x7E, 0xFF, 0xFF, 0xFF, 0xFF, 0x7E, 0x3C,
        0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x7E, 0x3C, 0x18
    }

    // Bagian 7 - Implementasi Detail Fungsi

// Fungsi untuk lampu sein kiri
void leftSignal() {
    static uint8_t currentFrame = 0;
    static uint32_t lastUpdate = 0;
    const uint32_t interval = 500; // Interval kedipan 500ms
    
    if (millis() - lastUpdate >= interval) {
        lastUpdate = millis();
        currentFrame = !currentFrame;
        
        if (currentFrame) {
            // Pola sein kiri menyala
            uint8_t leftPattern[8] = {
                0x00, 0x08, 0x1C, 0x3E, 0x7F, 0x3E, 0x1C, 0x08
            };
            displayPattern(leftPattern);
        } else {
            // Matikan display
            clearDisplay();
        }
    }
}

// Fungsi untuk lampu sein kanan
void rightSignal() {
    static uint8_t currentFrame = 0;
    static uint32_t lastUpdate = 0;
    const uint32_t interval = 500; // Interval kedipan 500ms
    
    if (millis() - lastUpdate >= interval) {
        lastUpdate = millis();
        currentFrame = !currentFrame;
        
        if (currentFrame) {
            // Pola sein kanan menyala
            uint8_t rightPattern[8] = {
                0x00, 0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10
            };
            displayPattern(rightPattern);
        } else {
            // Matikan display
            clearDisplay();
        }
    }
}

// Fungsi untuk lampu rem
void brakeLight() {
    static uint8_t intensity = 0;
    static uint32_t lastUpdate = 0;
    const uint32_t interval = 50; // Update setiap 50ms
    
    if (millis() - lastUpdate >= interval) {
        lastUpdate = millis();
        
        // Pola lampu rem dengan efek pulsing
        uint8_t brakePattern[8] = {
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
        };
        
        // Atur intensitas cahaya
        setIntensity(intensity);
        displayPattern(brakePattern);
        
        // Animasi pulsing
        static bool increasing = true;
        if (increasing) {
            intensity = min(15, intensity + 1);
            if (intensity >= 15) increasing = false;
        } else {
            intensity = max(5, intensity - 1);
            if (intensity <= 5) increasing = true;
        }
    }
}

// Fungsi untuk lampu hazard
void hazardLight() {
    static uint8_t currentFrame = 0;
    static uint32_t lastUpdate = 0;
    const uint32_t interval = 500; // Interval kedipan 500ms
    
    if (millis() - lastUpdate >= interval) {
        lastUpdate = millis();
        currentFrame = !currentFrame;
        
        if (currentFrame) {
            // Pola hazard menyala (kombinasi sein kiri dan kanan)
            uint8_t hazardPattern[8] = {
                0x00, 0x18, 0x3C, 0x7E, 0xFF, 0x7E, 0x3C, 0x18
            };
            displayPattern(hazardPattern);
        } else {
            // Matikan display
            clearDisplay();
        }
    }
}

// Fungsi untuk lampu parkir
void parkingLight() {
    static uint32_t lastUpdate = 0;
    const uint32_t interval = 1000; // Update setiap 1 detik
    
    if (millis() - lastUpdate >= interval) {
        lastUpdate = millis();
        
        // Pola lampu parkir (intensitas rendah)
        uint8_t parkingPattern[8] = {
            0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18
        };
        
        setIntensity(3); // Intensitas rendah
        displayPattern(parkingPattern);
    }
}

// Fungsi untuk mode custom pattern
void customPattern(uint8_t patternIndex) {
    if (patternIndex < NUM_PATTERNS) {
        displayPattern(patterns[patternIndex]);
    }
}

// Fungsi untuk mengatur kecerahan
void setBrightness(uint8_t level) {
    if (level <= 15) { // MAX7219 mendukung 16 level kecerahan (0-15)
        setIntensity(level);
    }
}

// Fungsi untuk efek transisi antar pola
void transitionEffect(uint8_t* oldPattern, uint8_t* newPattern) {
    // Efek fade out
    for (uint8_t i = 15; i > 0; i--) {
        setIntensity(i);
        displayPattern(oldPattern);
        delay(30);
    }
    
    // Efek fade in
    for (uint8_t i = 0; i < 16; i++) {
        setIntensity(i);
        displayPattern(newPattern);
        delay(30);
    }
}

// Fungsi untuk mode polisi/emergency
void policeMode() {
    static uint8_t phase = 0;
    static uint32_t lastUpdate = 0;
    const uint32_t interval = 200; // Update setiap 200ms
    
    if (millis() - lastUpdate >= interval) {
        lastUpdate = millis();
        
        switch(phase) {
            case 0: // Biru
                {
                    uint8_t bluePattern[8] = {
                        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00
                    };
                    displayPattern(bluePattern);
                }
                break;
                
            case 1: // Merah
                {
                    uint8_t redPattern[8] = {
                        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF
                    };
                    displayPattern(redPattern);
                }
                break;
                
            case 2: // Gelap
                clearDisplay();
                break;
        }
        
        phase = (phase + 1) % 3;
    }
}

// Fungsi untuk mode running light
void runningLight() {
    static uint8_t position = 0;
    static uint32_t lastUpdate = 0;
    const uint32_t interval = 100; // Update setiap 100ms
    
    if (millis() - lastUpdate >= interval) {
        lastUpdate = millis();
        
        uint8_t pattern[8] = {0};
        pattern[position / 8] = (1 << (position % 8));
        displayPattern(pattern);
        
        position = (position + 1) % 64; // 8x8 = 64 LED
    }
}

// Fungsi untuk mode night rider
void nightRiderEffect() {
    static uint8_t position = 0;
    static bool direction = true; // true = right, false = left
    static uint32_t lastUpdate = 0;
    const uint32_t interval = 75; // Update setiap 75ms
    
    if (millis() - lastUpdate >= interval) {
        lastUpdate = millis();
        
        uint8_t pattern[8] = {0};
        for (uint8_t i = 0; i < 3; i++) { // 3 LED width
            if ((position + i) < 8) {
                pattern[7] |= (1 << (position + i));
            }
        }
        displayPattern(pattern);
        
        if (direction) {
            if (position >= 5) direction = false;
            else position++;
        } else {
            if (position <= 0) direction = true;
            else position--;
        }
    }
}

// Fungsi untuk mode strobo
void strobeEffect() {
    static bool state = false;
    static uint32_t lastUpdate = 0;
    const uint32_t interval = 50; // Update setiap 50ms
    
    if (millis() - lastUpdate >= interval) {
        lastUpdate = millis();
        state = !state;
        
        if (state) {
            uint8_t pattern[8] = {
                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
            };
            setIntensity(15); // Full brightness
            displayPattern(pattern);
        } else {
            clearDisplay();
        }
    }
}

// Fungsi untuk mode animasi smooth
void smoothAnimation(uint8_t* pattern1, uint8_t* pattern2, uint16_t duration) {
    static uint32_t startTime = 0;
    static uint32_t lastUpdate = 0;
    const uint32_t updateInterval = 50; // Update setiap 50ms
    
    if (startTime == 0) startTime = millis();
    
    if (millis() - lastUpdate >= updateInterval) {
        lastUpdate = millis();
        
        float progress = (float)(millis() - startTime) / duration;
        if (progress > 1.0) progress = 1.0;
        
        uint8_t interpolatedPattern[8];
        for (uint8_t i = 0; i < 8; i++) {
            interpolatedPattern[i] = pattern1[i] + (pattern2[i] - pattern1[i]) * progress;
        }
        
        displayPattern(interpolatedPattern);
        
        if (progress >= 1.0) {
            startTime = 0; // Reset untuk animasi berikutnya
        }
    }
}
